<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://mike-dai.github.io/post/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Jul 2019 11:12:46 +0800</lastBuildDate>
    
	<atom:link href="https://mike-dai.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Blog</title>
      <link>https://mike-dai.github.io/post/blog/</link>
      <pubDate>Wed, 10 Jul 2019 11:12:46 +0800</pubDate>
      
      <guid>https://mike-dai.github.io/post/blog/</guid>
      <description>查询处理 查询计划 (Query Plan) DBMS将SQL语句转换为查询计划。运算符被安排在树形数据结构上，数据流的方向为从叶子指向根，树中根节点的输出就是查询的结果。通常，运算符是二元的（1-2个孩子）。可以用多种方式执行相同的查询计划。大多数DBMS尽可能使用索引扫描。
处理模型 (Processing Models) DBMS的处理模型会定义系统如何执行查询计划。不同的模型针对不同的工作负载进行将进行各种权衡。
迭代器模型 (Iterator Model) 这是最常见的处理模型，几乎每个DBMS都使用它。
 自上而下处理
 每个查询计划运算符都实现next函数：
 在每次调用next时，如果已经没有元组了，则运算符返回单个元组或空标记
 运算符实现一个循环，在其子代上调用next，然后检索它们的元组处理它们
  允许管道传输(pipelining)，DBMS在检索下一个元组之前，可以通过尽可能多的运算符处理元组。
 某些运算符将阻塞，直到孩子发送出所有元组（连接，子查询，排序）。
 使用（LIMIT）可轻松实现输出控制。
  物化模型 (Materialization Model) 每个运算符一次性处理其输入，然后一次性发出其输出。运算符“物化”它的输出为单一结果。
 自下而上处理。
 此方法更适用于OLTP，因为查询通常一次只访问少量元组。因此，检索元组的函数调用较少。
 对于具有较大中间结果的OLAP查询不利。
  矢量化模型 (Vectorization Model) 就像迭代器模型一样，每个运算符都实现了next函数。但每个运算符都会发出批量（即vector）的数据而不是单个元组。
 自上而下处理
 非常适合必须扫描大量元组的OLAP查询，因为调用next次数较少
  访问方法 (Access Method) 访问方法是DBMS如何访问存储在表中的数据。这些将是查询计划中最底层的运算符，将数据“喂”到它上面的运算符中。在关系代数中没有相应的运算符。
顺序扫描 (Sequential Scan) 对于表中的每一页，遍历每一页并从缓冲池中取出。对于每一页，遍历所有元组并评估期望值以决定是否包含元组。
优化：
 预取 (Prefetching)：提前获取下几页，以便DBMS不必阻塞。
 并行化：并行使用多个线程或多个进程执行扫描。
 缓冲池旁路 (Buffer Pool Bypass)：扫描运算符将从磁盘中获取的页面存储在其本地内存中而非缓冲池。这避免了顺序读入 (sequential flooding) 的问题。</description>
    </item>
    
  </channel>
</rss>